#!/usr/bin/python

import argparse
import os.path
import re
from subprocess import check_call, check_output
import sys
import yaml


def normalise_conf(conf):
    """generate full paths etc for easy application later."""
    def make_repos(thing, path_stack):
        if isinstance(thing, dict):
            repos = {}
            for key, subthing in thing.items():
                path = path_stack + (key,)
                repos.update(make_repos(subthing, path))
            return repos
        elif isinstance(thing, list):
            path = '/'.join(path_stack)
            repos = {}
            for name in thing:
                if name in repos:
                    raise ValueError("%r defined multiple times" % name)
                repos[name] = '%s/%s' % (path, name)
            return repos
        else:
            raise ValueError("%r is not a dict or list" % (thing,))
    conf['repos'] = make_repos(conf['repos'], ())
    return conf


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("refs", help="the yaml config file")
    parser.add_argument("output", help="where to put the downloaded repositories")
    parser.add_argument("repos", help="what repos to update", nargs="*")
    args = parser.parse_args()
    SRC_ROOT = os.path.abspath(args.output)
    with open(args.refs, 'rt') as arg_file:
        CONF = yaml.safe_load(arg_file.read())
    CONF = normalise_conf(CONF)

    if not os.path.lexists(SRC_ROOT):
        os.makedirs(SRC_ROOT)

    variables = []

    for repo, remote in CONF['repos'].items():
        if args.repos and repo not in args.repos:
            continue
        rd = os.path.join(SRC_ROOT, repo)

        if not os.path.isdir(os.path.join(rd)):
            check_call(['git', 'clone', remote, rd])

        refs = CONF['gerrit_refs'].get(repo, ())

        git_refs = ['master']
        for ref in refs:
            if len(ref.split('/')) != 3:
                # Weak heuristic, may need fixing.
                continue
            git_refs.append(
                '+refs/changes/%(ref)s:refs/changes/%(ref)s' % dict(ref=ref))
            #print ' '.join(['git', 'pull', remote, ref])
            #check_call(['git', 'pull', '--no-edit', remote, 'refs/changes/' + ref],
            #           cwd=rd)
        print 'fetching from %s %s' % (remote, git_refs)
        check_call(['git', 'fetch', remote] + git_refs, cwd=rd)

        if not refs:
            branch_name = 'master'
        else:
            components = []
            for ref in refs:
                segments = ref.split('/')
                if len(segments) == 3:
                    components.append(segments[1])
                else:
                    components.append(ref)
            branch_name = 'rollup_' + '_'.join(components)
        dirty = check_output(['git', 'status', '-z', '-uno'], cwd=rd)
        if dirty:
            check_call(['git', 'stash'], cwd=rd)
        branches = check_output(['git', 'branch', '-a'], cwd=rd)
        if ' ' + branch_name in branches:
            print 'Resetting existing branch %s...' % branch_name
            check_call(['git', 'checkout', branch_name], cwd=rd)
            check_call(['git', 'reset', '--hard', 'origin/master'], cwd=rd)
        else:
            check_call(['git', 'checkout', '-b', branch_name, 'origin/master'], cwd=rd)
        for ref in refs:
            if len(ref.split('/')) == 3:
                ref = 'refs/changes/%s' % ref
            check_call(['git', 'merge', '--no-edit', ref], cwd=rd)
        if dirty:
            check_call(['git', 'stash', 'pop'], cwd=rd)
        normalised_repo = re.sub('[^A-Za-z0-9_]', '_', repo)
        if repo not in CONF['gerrit_refs']:
            print 'no refs for %s' % repo
            variables.append((normalised_repo, rd, None))
        else:
            variables.append((normalised_repo, rd, branch_name))

    with open(args.refs + '.variables', 'wt') as output:
        for name, location, ref in variables:
            output.write('export DIB_REPOTYPE_%s=git\n' % name)
            output.write('export DIB_REPOLOCATION_%s=%s\n' % (name, location))
            if ref:
                output.write('export DIB_REPOREF_%s=%s\n' % (name, ref))
            else:
                output.write('unset DIB_REPOREF_%s\n'% name)
    return 0


sys.exit(main())
